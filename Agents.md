# Agents — Autonomous Crypto Trading Bot (Python)

This document defines agents, roles, responsibilities, flows, and boundaries to help coordinate development of the full project.

The overall goal is to build a **simulated** trading bot for **SOL/USDT** (and similar pairs) in **Python**, with:

- Daily self-optimization using OpenAI
- Combined strategies (technical indicators + ML)
- Full state persistence (SQLite or another local option)
- Automatic daily reports
- A web dashboard for monitoring
- A single entrypoint: `python run.py`

---

## 1. AGENT: Architect

**Role:** Design the overall bot architecture.

**Responsibilities:**
- Define the project folder structure and modules.
- Define contracts between layers (interfaces, basic DTOs).
- Define the persistence layer (simple SQLite with tables for: state, metrics, simulated trades, parameters).
- Define the main flows:
  - Continuous simulated trading cycle
  - Daily evaluation cycle
  - Automatic optimization flow with OpenAI
  - Recovery flow after shutdown
- Document the architecture under `/diagrams` and `/plans`.

**Deliverables:**
- Folder structure under `/src`
- `diagrams/architecture.mmd` and `diagrams/data_flow.mmd`
- Module descriptions in `Project_Plan.md` and phase plans

---

## 2. AGENT: Backend Developer (Python)

**Role:** Implement the internal bot logic following the defined architecture.

**Responsibilities:**
- Create modules under `/src/core`, `/src/exchange`, `/src/strategy`, `/src/evaluation`, etc.
- Implement:
  - Internal scheduling (main loop + daily tasks)
  - Config loading from `config.yaml`
  - Structured logging (JSON or text)
  - Paper trading module (simulated orders, PnL, fees)
  - Persistent state integration (via `state_manager`)

**Limits:**
- Do not develop strategy-specific trading logic until `Project_Plan` indicates it.
- Extension points are documented clearly in docstrings and comments.

---

## 3. AGENT: Data Scientist / ML

**Role:** Design and build ML/statistics components.

**Responsibilities:**
- Define and generate features from OHLCV and volume.
- Implement in `/src/ml`:
  - `feature_engineering.py`
  - `trainer.py`
  - `model_manager.py`
  - `signal_generator.py`
- Explore models such as:
  - Classification models (e.g., RandomForest, XGBoost, logistic regression)
  - Simple time-series models (e.g., regression; small recurrent nets if warranted)
- Produce outputs such as:
  - Probability the next window is bullish/bearish
  - “buy / sell / hold” signals with a confidence score
- Save and load models from `/src/data/models`

**Limits:**
- No heavy hyper-optimization; focus on a clear, extensible pipeline.
- Models should support incremental/daily retraining using local data.

---

## 4. AGENT: Evaluator / Self-Optimizer

**Role:** Evaluate bot performance and propose/apply automatic adjustments.

**Responsibilities:**
- Analyze at end of day:
  - Simulated PnL
  - Drawdown
  - Win rate
  - Risk metrics (simple Sharpe, etc.)
- Compute a **probability of consistent positive profit** using:
  - Statistical metrics
  - ML signals
  - System stability
- Build a daily log and (via `/src/evaluation/openai_optimizer.py`) send a payload to the OpenAI API (user supplies the key) including:
  - Daily summary
  - Key stats
  - Current parameters
- Receive OpenAI recommendations (e.g., adjust an RSI threshold, change training window, adjust position size) and apply changes in a controlled way to persistent state.

**Special goal:**
- When the Evaluator estimates **≥ 30% probability** of consistent positive profit (per configurable rules), it must:
  - Record that condition in the database
  - Expose a flag the frontend can display (e.g., “Probability condition reached, review for real funds”)

---

## 5. AGENT: Report Manager

**Role:** Generate daily reports and store them in an organized manner.

**Responsibilities:**
- Build in `/src/reports`:
  - `reporter.py`
  - HTML/Markdown templates under `/src/reports/templates`
- Generate each day:
  - A Markdown daily summary
  - An HTML report (for the dashboard)
  - A JSON structured report (for integrations)
- Store reports under `/reports/YYYY-MM-DD/`.

**Minimum report contents:**
- Core metrics: PnL, number of trades, win rate, drawdown
- Comments/notes generated by the Evaluator/ML
- Relevant parameters used that day (thresholds, position size, etc.)
- Status of the ≥ 30% probability flag

---

## 6. AGENT: Frontend/UI Developer

**Role:** Create a lightweight web UI to visualize bot state.

**Responsibilities:**
- Implement a small web server in `/src/frontend/server.py`, ideally with:
  - FastAPI (or another lightweight alternative)
  - Templates (Jinja2 / HTMX) under `/src/frontend/templates`
  - Static files under `/src/frontend/static`
- The dashboard should display:
  - Bot runtime status
  - Today’s PnL and recent days
  - Latest generated signals
  - Current relevant parameters (position size, thresholds, etc.)
  - Indicator for “probability ≥ 30%” status
- Include a simple periodic refresh mechanism (polling or HTMX).

**Limits:**
- The frontend must **not** start/stop the bot directly; it is an observation layer only.
- No user authentication required for the first version (but leave hooks for it).

---

## 7. AGENT: Integrator / DevOps

**Role:** Ensure everything works end-to-end and is easy to run.

**Responsibilities:**
- Create and maintain:
  - `run.py` as the main entrypoint
  - `requirements.txt` with project dependencies
- Ensure the project starts with:
  ```bash
  python run.py
  ```
- Configure internal scheduling:
  - Continuous cycle (e.g., every X seconds to evaluate market conditions)
  - Daily task for evaluation and optimization
- (Optional) Provide a `Dockerfile` and/or deployment instructions in `README.md`

---

## Main System Flows

### Flow A — Continuous simulated trading cycle

1. Load configuration and persistent state.
2. Fetch recent market data (OHLCV).
3. Generate technical + ML signals.
4. Decide simulated operations (paper trading).
5. Update state (simulated positions, PnL, metrics).
6. Log each decision and simulated trade.

### Flow B — Daily evaluation and optimization

1. At end of day (timezone configurable), build a summary:
   - Daily PnL
   - Number of trades and win rate
   - PnL evolution
   - Risk metrics (Sharpe, simple max drawdown)
2. Compute a “probability of consistent positive profit” using rules and/or ML.
3. Send an OpenAI payload with:
   - Daily summary
   - Current parameters
   - Constraints (e.g., do not increase risk above X)
4. Receive OpenAI recommendations and apply them (within safe limits).
5. Persist everything to the database and reports.

### Flow C — Recovery after shutdown

1. On startup, read from SQLite:
   - Current parameters
   - Simulated position state
   - Trained ML models or their metadata
   - Last estimated probability
2. Resume continuous execution without losing coherence.
3. Log any inconsistencies and proceed safely.

---

## Golden Rules

- The design must be modular and extensible: new strategies, new pairs, new ML models.
- `run.py` must be the only mandatory entrypoint for end users.
- Every automatic adjustment must:
  - Be traceable (who suggested it, when, and why).
  - Be persisted before it becomes effective (in the next cycle).
- Prefer **robustness** over complexity: clarity first, sophistication later.
